# Description: Custom file storage
# The CustomStorage class overrides get_valid_filename in django.utils.text.py, which is invoked every time Django saves a record with a file field
# that has changed. It makes sure all the characters in the file name are among those the function accepts as valid, and it renames a file using a _
# and random six letters if the file name already exists. This function improves on get_valid_name in two ways. First, the original version forgot to
# make sure that the file name could not be a Windows reserved word or start with a . on Mac OS X. Second, this file offers extra keyword arguments
# that allow the developer to examine the tradeoff between security and user freedom. Incidentally, Django will also use CustomStorage to
# automatically rename any files generated by MetadataRestrictedFileField, such as thumbnails or copies of the file using another file format.
#
# This class uses two settings in settings.py. First, ALLOW_SPACES=False by default because it keeps Django's default behavior of replacing spaces with underscores. Spaces can lead to security vulnerabilities in modules that
# use UNIX command line. For example, if a program used the command "cat <filename>" without putting the file name in quotes, then it could interpret
# the parts after the first space as being related to commands. Second, ALLOW_NON_UNICODE_ALPHANUMERIC=False by default. This setting allows accented characters, CJK characters,
# and dashes and dots. Setting ALLOW_NON_UNICODE_ALPHANUMERIC=True will also let @, #, etc. through, but not anything disallowed by common file systems.

from django.core.files.storage import FileSystemStorage
from django.conf import settings
import re
import os
from django.utils.encoding import force_text

class CustomStorage(FileSystemStorage):
    def __init__(self, *args, **kwargs):
        super(CustomStorage,self).__init__(*args, **kwargs)
    def get_valid_name(self, full_file_name):
        return get_valid_file_name(full_file_name)

# Use this function whenever you rename a file, excluding the extension, based on some user-generated string. This will ensure it is valid using the rules you have for your back end. 
# Input: full_file_name, a string following the pattern "name" or "name.extension". allow_spaces and allow_non_unicode_alphanumeric are Boolean.
# Output: A modified version of full_file_name.
def get_valid_file_name(full_file_name):
    # Convert the file name to a Unicode string. Strip leading and trailing whitespace. Trailing whitespace is invalid
    # in a Windows file name.
    full_file_name = force_text(full_file_name).strip()
    if not settings.ALLOW_SPACES:
        full_file_name = full_file_name.replace(' ', '_')

    if settings.ALLOW_NON_UNICODE_ALPHANUMERIC:
        # Remove any character that isn't supported on various common file systems.
        # Windows NFTS: \ / ? < > : " * |. This covers UNIX, for which only "/" is usually disallowed.
        # Windows FAT: ^
        full_file_name = re.sub(r'[\\/?<>:"*|^]', '', full_file_name)
    else:
        # Remove any character that isn't Unicode alphanumeric or a dash. The (?u) is a flag that modifies the \w for alphanumeric.
        # This statement allows characters with accents and Chinese, Japanese, and Korean characters, but it removes characters like # and @.
        full_file_name = re.sub(r'(?u)[^-\w.]', '', full_file_name)
    
    # Begin the validation that needs to look at only the part of the file name without the extension.
    name, extension = os.path.splitext(full_file_name)
    # Mac OS X: File names cannot begin with a dot. Check for trailing whitespace again on the name portion.
    name = name.rstrip().lstrip('.')
    # Make sure that all the characters haven't been removed, so that the file name will not begin with a . on Mac OS X again.
    # On Windows, both the file name and the file name plus the extension cannot be a reserved word. 
    # Rename the file to an underscore if either is the case, which will be rare or deliberate. 
    # It doesn't matter if there is already a file with an underscore name, because Django has a separate built-in function for ensuring uniqueness.
    if name in ['', 'com1', 'com2', 'com3', 'com4', 'com5', 'com6', 'com7', 'com8', 'com9', 'lpt1', 'lpt2', 'lpt3', 'lpt4', 'lpt5', 'lpt6', 'lpt7',
                'lpt8', 'lpt9', 'con', 'nul', 'prn']:
        name = '_'
    if extension == '':
        return name
    else:
        return name+extension

